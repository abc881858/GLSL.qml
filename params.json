{
  "name": "Glsl.qml",
  "tagline": "Tell you how to use glsl in qml type ShaderEffect",
  "body": "# GLSL.qml\r\n\r\nTell you how to use glsl in qml type ShaderEffect.\r\n\r\nqml中的glsl学习。\r\n\r\n> 注意：直接对 Item 的 `layer.effect` 设置着色器时，要设置 `layer.enabled: true`。\r\n\r\n## 线性渐变\r\n\r\n```qml\r\nimport QtQuick 2.0\r\n\r\nShaderEffect {\r\n    id: root\r\n    width: 400\r\n    height: 400\r\n\r\n    //![1]\r\n    property size uResolution: Qt.size(root.width, root.height)\r\n    //![1]\r\n    fragmentShader: \"\r\n            uniform vec2 uResolution;\r\n            void main() {\r\n                vec2 position = gl_FragCoord.xy/uResolution;\r\n                float gradient = position.x;\r\n                gl_FragColor = vec4(0., gradient, 0., 1.);\r\n            }\"\r\n}\r\n```\r\n\r\n效果如下：\r\n\r\n![doc/images/001.png](doc/images/001.png)\r\n\r\n进阶：\r\n\r\n```\r\nimport QtQuick 2.0\r\n\r\nShaderEffect {\r\n    id: root\r\n    width: 400\r\n    height: 400\r\n\r\n    property real value: 0\r\n    NumberAnimation on value {\r\n        duration: 2500\r\n        from: 0\r\n        to: 3\r\n        loops: Animation.Infinite\r\n    }\r\n\r\n    //![1]\r\n    property size uResolution: Qt.size(root.width, root.height)\r\n    //![1]\r\n\r\n    //![2]\r\n    // gl_FragCoord 这个片段独有的变量存放了当前片段相对窗口的坐标。\r\n    // 这个值是从顶点生成片段之后对图元进行固定函数插值的结果\r\n    // 你可以通过除法 gl_FragCoord.xy/uResolution 来把你的像素坐标转化到 0.0 ≤ xy ≤ 1.0 这个范围\r\n    // 这在很多时候能大大简化像素着色器的计算。\r\n    // 这也是 gl_FragColor 的绝佳取值范围，现在让我们来看一些渐变！\r\n    fragmentShader:\"\r\n            uniform vec2 uResolution;\r\n            uniform float value;\r\n            void main() {\r\n                vec2 position = gl_FragCoord.xy/uResolution;\r\n                float gradient = (position.x+position.y)/value;\r\n                gl_FragColor = vec4(0., gradient, 0., 1.);\r\n            }\"\r\n    // 通过修改 float gradient = position.x; 横向\r\n    // 通过修改 float gradient = position.y; 竖向\r\n    // float gradient = (position.x+position.y)/2.; 斜向\r\n    //![2]\r\n\r\n}\r\n```\r\n\r\n## 2D 圆盘\r\n\r\n```\r\nimport QtQuick 2.0\r\n\r\nShaderEffect {\r\n    id: root\r\n    width: 400\r\n    height: 400\r\n    property size uResolution: Qt.size(root.width, root.height)\r\n\r\n    fragmentShader:\"\r\n            uniform vec2 uResolution;\r\n            void main() {\r\n                vec2 center = vec2(uResolution.x/2., uResolution.y/2.);\r\n\r\n                // 2\r\n                float radius = uResolution.x/2.;\r\n\r\n                // 3\r\n                vec2 position = gl_FragCoord.xy - center;\r\n\r\n                // 4\r\n                if (length(position) > radius) {\r\n                  gl_FragColor = vec4(vec3(0.), 1.);\r\n                } else {\r\n                  gl_FragColor = vec4(vec3(1.), 1.);\r\n                }\r\n            }\"\r\n}\r\n```\r\n\r\n![doc/images/002.png](doc/images/002.png)\r\n\r\n1. 圆盘的 center 会处于你屏幕的正中央。\r\n\r\n2. 圆盘的 radius 会是你屏幕宽度的一半。\r\n\r\n3. position 是当前像素的坐标相对圆盘圆心的偏移值。可以想象成是一个向量从圆盘圆心指向当前位置。\r\n\r\n4. length() 用于计算向量长度，在这个例子里长度是根据勾股定理 √(position.x²+position.y²) 来计算的。\r\n\r\n    A.如果结果比 radius 大，说明当前像素在圆盘区域外，那么就染成黑色。\r\n\r\n    B.否则，说明当前像素在圆盘区域内，染成白色。\r\n\r\n作为对这个行为的补充说明，可以参看 圆形方程 (x-a)²+(y-b)² = r² 。注意 r 是半径， ab 是圆心，而 xy 是圆上所有点集。\r\n\r\n圆盘是平面上被圆形围住的一块区域，上面的 if-else 语句会准确的把它画出来！\r\n\r\n## 细圆环\r\n\r\n```qml\r\nimport QtQuick 2.0\r\n\r\nShaderEffect {\r\n    id: root\r\n    width: 400\r\n    height: 400\r\n    smooth: true\r\n    property size uResolution: Qt.size(root.width, root.height)\r\n    fragmentShader:\"\r\n            uniform vec2 uResolution;\r\n            void main() {\r\n                vec2 center = vec2(uResolution.x/2., uResolution.y/2.);\r\n                float radius = uResolution.x/2.;\r\n                vec2 position = gl_FragCoord.xy - center;\r\n                float thickness = radius/50.;\r\n\r\n                if ((length(position) > radius) || (length(position) < radius-thickness)) {\r\n                    gl_FragColor = vec4(vec3(0.), 1.);\r\n                } else {\r\n                    gl_FragColor = vec4(vec3(1.), 1.);\r\n                }\r\n            }\"\r\n}\r\n```\r\n\r\n![doc/images/003.png](doc/images/003.png)\r\n\r\n> 试着根据 radius 创建一个叫 thickness 的新变量，并在 if-else 条件中使用。\r\n\r\n## 3D球体\r\n\r\n```\r\nimport QtQuick 2.0\r\n\r\nShaderEffect {\r\n    id: root\r\n    width: 400\r\n    height: 400\r\n    smooth: true\r\n    property size uResolution: Qt.size(root.width, root.height)\r\n    fragmentShader:\"\r\n            uniform vec2 uResolution;\r\n            void main() {\r\n                vec2 center = vec2(uResolution.x/2., uResolution.y/2.);\r\n                float radius = uResolution.x/2.;\r\n                vec2 position = gl_FragCoord.xy - center;\r\n                float thickness = radius/50.;\r\n                float z = sqrt(radius*radius - position.x*position.x - position.y*position.y);\r\n                z /= radius;\r\n                gl_FragColor = vec4(vec3(z), 1.);\r\n            }\"\r\n}\r\n```\r\n\r\n![doc/images/004.png](doc/images/004.png)\r\n\r\n---\r\n\r\n[为新手准备的 Codea 着色器（Shader）教程](http://my.oschina.net/freeblues/blog/336055)\r\n\r\n[OpenGL ES像素着色器教程](http://www.tuicool.com/articles/VFnAFbB)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}